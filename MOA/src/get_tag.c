//  get_tag.c
//  Last editted on 27 June, 2000 by Gil Toombes.  
//  Loads the 8 ATOD values stored in TV6 files generated by the 1K detector.

//  During an exposure, TV6 monitors four ATOD ports.  These can monitor temperature,
//  beam current and other goodies.  At the end of the exposure, it records the 
//  average and current value of each port.   	
//  These are recorded as non-standard tags in the tiff header.
//  There is a routine called tiffdump.c on linux which allows you to look at these
//  tags.  Unfortunately, the support for tiffdump.c is mostly unix based so I 
//  couldn't easily port it to Windows.
//  TV6 has its own TIFF reader but this is clunky, non-universal and ugly. 
//  It is in TIFF_IN.c and TIFF2.h in the TV6 directory.
//  Another reason for not using it is I'm sick of going through that code.
//  Anyway, this is a hacky fix for Windows to get those eight numbers.
//  By a lucky coincidence, when TV6 on the 1K detector records a tiff, it seems
//  always to write these numbers in the same place.  If we treat the header as
//  a sequence of long integers, then the first occurs at an offset of 
//  START_DATA=124 and the last is at 131.  AMOUNT_DATA=8 
//  So get_tag() reads in the first (START_DATA+AMOUNT_DATA)*sizeof(long int)
//  bytes.  It copies the eight numbers across into the array given and leaves.

//  Returns 0 if successful.  -1 if error.
//  Note, if numbers do not exist in header get_tag has no way of checking and may
//  return gibberish


#include "fcntl.h"
#include "stdio.h"
#include "stdlib.h"

int get_tag(char *, double *);

int get_tag(char * filename, double * tag_vals)
{
  int fd; 
  int i;
  long int * temp;  
  int START_DATA=124; // the offset in sizeof(long int)s to the first ATOD number
  int AMOUNT_DATA=8;  // the amount of data.

  // open the file and read in the header

  fd = open(filename,O_RDONLY);
  if (fd== -1)
		{
			fprintf(stderr,"get_tag.c could not open filename %s.", filename);
         return -1;
		}
  temp = (long int *)malloc((START_DATA+AMOUNT_DATA)*sizeof(long int));
  if (temp==NULL)
		{
			fprintf(stderr,"get_tag.c could no allocate sufficient memory.");
         return -1;
      }
  read(fd,temp,(START_DATA+AMOUNT_DATA)*sizeof(long int)); 
     // This needs an error handler.

  // Transfer the goodies across
  for (i=0;i<AMOUNT_DATA;i++)  tag_vals[i]=(double)(temp[i+START_DATA]);

  // Free up memory
	free(temp);
   return 0;
}
